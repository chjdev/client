"""
    Fanlens API

     Fanlens API to handle \"activities\". Predictions are performed automatically and can be managed here ## Concepts The API consists of 4 main concepts: sources, activities and tags (bundled in tagsets) and models used for predictions. * An activity is a text based action performed by a user, e.g. a Facebook Comment or a Tweet. * A source is the originator of these activities and is used for importing. Currently Facebook, Twitter, and Generic Sources are supported. * A tag is a piece of meta information that is used to build specialized speech models, e.g. \"positive\", or \"negative\". They are bundled in tagsets for convenience, e.g. \"Emotion\".

    OpenAPI spec version: 4.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import unittest
from typing import List

from client.models.activity import Activity
from client.models.activity_list import ActivityList
from test.activity import TestActivityApi

_DEFAULT_ACTIVITY_COUNT = 8


class TestActivityRootApi(TestActivityApi):
    """Tests for the activity fetching api"""

    def test_root_get(self) -> None:
        """Check a simple default fetch."""
        activities_list: ActivityList = self.api.root_get()
        self.assertIsNotNone(activities_list)
        activities: List[Activity] = activities_list.activities
        self.assertEqual(len(activities),
                         _DEFAULT_ACTIVITY_COUNT,
                         f'root_get Does not return default amount ({_DEFAULT_ACTIVITY_COUNT}) of activities!')

    def test_root_get_count(self) -> None:
        """Check a fetching with count and capping with max id."""
        activity_count = 17
        activities_list: ActivityList = self.api.root_get(count=activity_count)
        self.assertIsNotNone(activities_list)
        activities: List[Activity] = activities_list.activities
        self.assertEqual(len(activities),
                         activity_count,
                         f'root_get Does not return {activity_count} amount of activities!')
        activity_ids = [activity.id for activity in activities]
        self.assertEqual(len(activity_ids), len(set(activity_ids)), "Activity ids are not unique!")

    def test_root_get_maxid(self) -> None:
        """ Test the maxid parameter """
        max_activity, = self.api.root_get(count=1).activities
        max_id = max_activity.id
        capped_activities_list: ActivityList = self.api.root_get(max_id=max_id)
        capped_activities: List[Activity] = capped_activities_list.activities
        self.assertEqual(len(capped_activities),
                         _DEFAULT_ACTIVITY_COUNT,
                         f'root_get Does not return {_DEFAULT_ACTIVITY_COUNT} amount of activities!')
        capped_activity_ids = [capped_activity.id for capped_activity in capped_activities]
        self.assertEqual(len(capped_activity_ids), len(set(capped_activity_ids)), "Activity ids are not unique!")
        self.assertNotIn(max_id, capped_activity_ids, f'`max_ic` {max_id} is present in the capped subset!')
        self.assertTrue(all([capped_activity_id < max_id for capped_activity_id in capped_activity_ids]),
                        'Capped activities have ids greater than max id')

    def test_root_get_source_ids(self) -> None:
        """ Test source id filtering """
        self.fail()

    def test_root_get_tagset_ids(self) -> None:
        """ Test source id filtering """
        self.fail()

    def test_root_get_tags(self) -> None:
        """ Test source id filtering """
        self.fail()

    def test_root_get_random(self) -> None:
        """ Test source id filtering """
        self.fail()

    def test_root_get_daterange(self) -> None:
        """ Test source id filtering """
        self.fail()

    def test_root_get_languages(self) -> None:
        """ Test source id filtering """
        self.fail()

    def test_root_get_combinations(self) -> None:
        """ Test source id filtering """
        self.fail()


if __name__ == '__main__':
    unittest.main()
